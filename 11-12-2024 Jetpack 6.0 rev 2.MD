
# Notes
The project is conducted with a Jetson Orin Nano Developer Kit 8GB. It originally started with Jetson firmware 4.1 causing a different boot up than the one recommended. 

# 1.1 Recommended First Boot: Flashing Jetpack Jetson Orin Nano Developer Kit Using Ethcher

This will depend on on what firmware version in on ther Jetson Board.


To prepare your microSD card, you’ll need a computer with Internet connection and the ability to read and write SD cards, either via a built-in SD card slot or adapter.

1. Download the Jetson Orin Nano Developer Kit SD Card image from [JetPack SDK Page](https://developer.nvidia.com/embedded/jetpack-sdk-60) , and note where it was saved on the computer.
- **Before writing the sd card go to the disc manager and ensure that there are no pations on the sd card you will not need to worry about this with a new sd card**
2. Write the image to your microSD card by following the instructions [here](https://developer.nvidia.com/embedded/learn/get-started-jetson-orin-nano-devkit) according to the type of computer you are using: Windows, Mac, or Linux.

### Use the following instructions to download [Ether](https://etcher.balena.io/)

## Instructions for Linux
You can either write the SD card image using a graphical program like Etcher, or via command line.

### **Etcher Instructions**

1. Download, install, and launch Etcher.
![alt text](image-8.png)

2. Click “Select image” and choose the zipped image file downloaded earlier.
3. Insert your microSD card. If you have no other external drives attached, Etcher will automatically select the microSD card as target device. Otherwise, click “Change” and choose the correct device.
![alt text](image-9.png)

4. Click “Flash!” Your OS may prompt for your username and password before it allows Etcher to proceed.
![alt text](image-10.png)
It will take Etcher 10-15 minutes to write and validate the image if your microSD card is connected via USB3.

5. After Etcher finishes, eject the SD Card using Files application:
![alt text](image-11.png)

6. Physically remove microSD card from the computer.

## Command Line Instructions
1. Open the Terminal application by pressing `Ctrl + Alt + t`.

2. Insert your microSD card, then use a command like this to show which disk device was assigned to it:

`dmesg | tail | awk '$2 == "sd" {print}'`


![alt text](Pictures/Jetson_Orin_Nano_8GB/Setup/Jetson_Nano-Getting_Started-Linux-Terminal_Disk_Assign.png)

3. Use this command to write the zipped SD card image to the microSD card:

`/usr/bin/unzip -p ~/Downloads/jp60-orin-nano-sd-card-image.zip | sudo /bin/dd of=/dev/sda bs=1M status=progress
`

For example:

![alt text](Pictures/Jetson_Orin_Nano_8GB/Setup/Jetson_Nano-Getting_Started-Linux-Terminal_Disk_Write.png)

When the dd command finishes, eject the disk device from the command line:
`sudo eject /dev/sda`

4. Physically remove microSD card from the computer.

After your microSD card is ready, proceed to [Setup your developer kit](https://developer.nvidia.com/embedded/learn/get-started-jetson-orin-nano-devkit#setup).

### If this doesn't work use the Jetpack 5.1.3 instead of Jetpack 6.0. Use the following [link](https://developer.nvidia.com/embedded/jetpack-sdk-513)

# Setup and First Boot
**Setup Steps**
1. Insert the microSD card (with system image already written to it) into the slot on the underside of the Jetson Orin Nano module.
2. Power on your computer display and connect it.
3. Connect the USB keyboard and mouse.
4. Connect the provided power supply. The Jetson Orin Nano Developer Kit will power on and boot automatically.

![alt text](Pictures/Jetson_Orin_Nano_8GB/Setup/jetson-orin-nano-dev-kit-sd-slot.jpg)

**First Boot**

A green LED next to the USB-C connector will light as soon as the developer kit powers on. When you boot the first time, the Jetson Orin Nano Developer Kit will take you through some initial setup, including:

- Review and accept NVIDIA Jetson software EULA
- Select system language, keyboard layout, and time zone
- Connect to Wireless network
- Create username, password, and computer name
- Log in

**After Logging In**
You will see this screen. Congratulations!

![alt text](Pictures/Jetson_Orin_Nano_8GB/Setup/Getting_started-Jetson_Xavier_NX-screenshot.png)

# 1.2 Flash to Jetpack +6.0 If Software Won't Update From 4.1 -> 5.1.3 -> +6.0

### Equitment needed
- Jetson Orin Nano Dev Kit
- Host PC running on **Unbuntu 20.04** with **Nvidia SDK Manager 2.2.0**
- 128 gb sc card
- 500 gb NVMe
- Nvidia Jetson Power cable (19.0V, 2.37A)
- Data capable usb to type-c
- Jumper wire
- Display with display port
- Display port cable
- Keyboard
- Mouse

### Hareware Setup
1. Install blank sd card and blank NVMe
2. Connect juper cable to put the Jetson in Force Recovery mode. (This enbles the board to be detected by the SDK manager)

![alt text](image-18.png)

3. Connect the usb to host computer and the other end into the type-c port on the Jetson.

![alt text](image-19.png)

4. Connect the power source to the Jetson.

![alt text](image-20.png)

5. Open the SDK Manager (2.2.0 version ) on the Host computer (Ubuntu 20.04)
6. Select The Jetson Orin Nano Developer Kit
![alt text](image-21.png)
### Flashing Jetpack 5.1.3

![alt text](image-22.png)
2. Continue to step 2 and **ONLY SELECT** Jetson Linux under TARGET COMPONENTS. As the other componets are not needed at this time.
![alt text](image-23.png)
3. Before proceeding to step 3 **DISCONNECT** the jumper wire taking the Jetson out of force recovery mode.
4. It will state the specified folder doesn't exist. Click **Create**
![alt text](image-24.png)
5. Next it will ask for your password.
![alt text](image-25.png)
Then all of the host componets will be installed and the Jetson Linux image will be created.
6. Once the OS image is ready the following screen will appear. Select the following parameters shown in the picture.
![alt text](image-26.png)
Once the parameters are selected click flash.
### Flashing Jetpack 6.0
1. Select the following Parameters in Step 1 of SDK Manager.
![alt text](image-27.png)
2. Continue to step 2 unsure that Jetson Linux and Jetson RUntime Components are selected under TARGET COMPONENTS.
![alt text](image-28.png)
3. Before proceeding to step 3 **DISCONNECT** the jumper wire taking the Jetson out of force recovery mode.

4. It will state the specified folder doesn't exist. Click **Create**
![alt text](image-24.png)
5. Next it will ask for your password.
![alt text](image-25.png)
Then all of the host componets will be installed and the Jetson Linux image will be created.



# 2. Run Jetson Orin Nano from SSD
In the build instruction we applied an SSD NVMe on to the Jetson NX. We will now make use of this SSD by switching the rootfs to point to the SSD. In effect, the system will now run from the SSD, the SD card is only there to boot the system. Therefore everything you install on your system will automatically installed on the SSD.

Please follow this tutorial [here](https://www.jetsonhacks.com/2020/05/29/jetson-xavier-nx-run-from-ssd/) that has both video and commands integrated to enable your Jetson NX to run from the SSD

**I highly recommend going to the "here" link above it is very helpful even though it is meant for the Jetson Xavier NX**

**Important**
```
These script changes the rootfs to the SSD after the kernel image is loaded from the eMMC/SD card. For the Xavier NX, you will still need to have the SD card installed for booting. As of this writing, the default configuration of the Jetson NX does not allow direct booting from the NVMe.
```
The **here** link will take you to a cite and execute the following steps

1. Ensure the SSD is correctly installed

2. Watch video on how to format SSD using this [link](https://youtu.be/ZK5FYhoJqIg)
3. Open a terminal window on the Jetson and run the following commands

**Note** :*You should do this process directly after creating a new SD card.*
On the [JetsonHacks account on Github](https://github.com/jetsonhacks/rootOnNVMe), there is a repository rootOnNVMe. Clone the repository:

```
git clone https://github.com/jetsonhacks/rootOnNVMe
```

and switch over to that repository’s directory:

```
cd rootOnNVMe
```

Next, copy the rootfs of the eMMC/SD card to the SSD

```
./copy-rootfs-ssd.sh
```

Finally, we will add a service which will run a script when the system starts up. The script will “pivot the root” to the SSD so that the system will run from the SSD.

```
./setup-service.sh
```
## 3. Configuring WiFi and SSH

### Connect to Wifi 

Go to top right corner and select network

**Note:** If you are using Labnet you will need to add the MAC address to the Network. To find the MAC address use the command `ip link show`

Here is an example.

![alt text](IMG_4150.jpg)

### Configure SSH

**Setting static IP Address**

Start by finding the wifi connection device. This can be down by running `nmcli d` then use the device name for wifi.
![alt text](image-17.png)
For the example above the device name is wlan0

1. To get the currently-assigned IP address use the command `ip addr show dev wlan0`.

![alt text](image-12.png)
Currently-connected WiFi IP address.¶

2. To set a static IP address, you will also need to know the name of the connection. This is usually the same as the SSID of the WiFi network but not always. To see the list of current connections, use the command `nmcli c show`.

![alt text](image-13.png)

List of connections.¶

3. To set a static IP address use the command sudo `nmcli c mod [CONNECTION_NAME] ipv4.address [NEW_ADDRESS]/[CIDR]` where `[CONNECTION_NAME]` is replaced with the name of your WiFi connection that you got from step 8, `[NEW_ADDRESS]` is replaced with the static IP address that you want to set, and `[CIDR]` is the [CIDR representation](https://www.ionos.com/digitalguide/server/know-how/cidr-classless-inter-domain-routing/) of the subnet (usually 24).

![alt text](image-14.png)
Setting static IP address.¶

4. To set the connection’s default gateway, use the command `sudo nmcli c mod [CONNECTION_NAME] ipv4.gateway [GATEWAY_IP]` where `[CONNECTION_NAME]` is replaced with the name of your WiFi connection that you got from step 8 and `[GATEWAY_IP]` is replaced with the IP address of your WiFi network’s gateway/router.

![alt text](image-15.png)
Setting IP gateway.¶

5. To set the connection’s DNS servers, use the command `sudo nmcli c mod [CONNECTION_NAME] ipv4.dns "[DNS_SERVER1]"` where `[CONNECTION_NAME]` is replaced with the name of your WiFi connection that you got from step 8 and `[DNS_SERVERS]` is replaced with a comma-separated list of DNS server IP addresses. Google DNS servers at 8.8.8.8 and 8.8.4.4 are recommended.

6. To disable DHCP and always use the static IP address on this connection, use the command `sudo nmcli c mod [CONNECTION_NAME] ipv4.method manual` where `[CONNECTION_NAME]` is replaced with the name of your WiFi connection that you got from step 8.

![alt text](image-16.png)
Setting connection to always use static IP.¶

7. To save the changes you’ve made, run the command `sudo nmcli c up [CONNECTION_NAME]` where `[CONNECTION_NAME]` is replaced with the name of your WiFi connection that you got from step 8.

8. To verify that you can SSH into the NVIDIA Jetson Orin Nano Developer Kit, verify that the Pit/Host PC is connected to the same network as the Jetson Orin Nano Developer Kit and use an SSH client on the Host PC to connect to the new IP address of the Developer Kit. On Linux this would be done with the command ssh f1tenth@[IP_ADDRESS] where [IP_ADDRESS] is replaced with the static IP address that you assigned to the Developer Kit. After you have verified that SSH works correctly, you can close the connection to the Developer Kit in your terminal emulator.
**After setup SSH using following command**

`ssh -p 22 User@ip adress`

**example:**
`ssh -p 22 darc-f1@10.152.69.100`

## 4. Updating Packages
All further steps assume that your NVIDIA Jetson Orin Nano Developer Kit is connected to the internet. You can execute all the commands directly in the terminal application of the NVIDIA Jetson. Now we are updating the Ubuntu system on the Jetson NX.

1. To update the list of available packages, run `sudo apt update`.

2. To install all available updates, run `sudo apt full-upgrade`.

3. Once all packages have been upgraded run `sudo reboot` to restart the Developer Kit and apply any changes.

## 5. Setup Bluetooth and Connect Controller
#### - Steps to Setup Bluetooth on Jetson Orin Nano:
Update System Packages: Make sure the system is up to date.

```
sudo apt update
sudo apt upgrade
```

#### - Install Bluetooth Packages: Install the necessary Bluetooth packages if they’re not already installed.

```
sudo apt install bluez bluez-tools
sudo apt install pulseaudio pulseaudio-module-bluetooth
```

#### - Enable Bluetooth Service: Start and enable the Bluetooth service.

```
sudo systemctl start bluetooth
sudo systemctl enable bluetooth
```

If your adapter is detected, you should see output like hci0: Type: BR/EDR .... If no device is found, it might be due to a missing driver or unsupported hardware.

#### Check if bluez and bluez-tools are installed:
Run this command:

```
sudo dpkg -l | grep bluez
```
**If the packages are installed, you should see an output like this:**

```
ii  bluez          <version>     <architecture>   <description>
ii  bluez-tools    <version>     <architecture>   <description>
```

Run this command:

```
dpkg -l | grep pulseaudio
```

This will show all ```pulseaudio``` related packages that are installed. Look for ```pulseaudio``` and ```pulseaudio-module-bluetooth``` in the output. If installed, the output will look similar to:

```
ii  pulseaudio                     <version>     <architecture>   <description>
ii  pulseaudio-module-bluetooth     <version>     <architecture>   <description>
```

If they are not installed, there will be no output or only partial results.

#### Now you should be able to go to settings and connect the controller

## 6. Creating a Swapfile

1. Run the following commands to create a swapfile which can help with memory-intensive tasks

```
sudo fallocate -l 4G /var/swapfile
sudo chmod 600 /var/swapfile
sudo mkswap /var/swapfile
sudo swapon /var/swapfile
sudo bash -c 'echo "/var/swapfile swap swap defaults 0 0" >> /etc/fstab'
```

# 2. Connecting the Pit/Host and the Jetson Orin Nano

## Overview

We could now log into the Jetson using a monitor, keyboard, and mouse, but ideally we would want remote access when we’re driving the car. Throughout this tutorial, you will be asked to configure the Jetson’s and your laptop’s network settings. Make sure to get these right! Using the wrong IP address may lead to conflicts with another classmate, meaning neither of you will be able to connect.

If your **Pit/Host** computer has WiFi capability, you connect both the computer and the F1TENTH car to a wireless router which reserves a static IP address for Jetson NX on the vehicle.

If the **Pit/Host** computer doesn’t have Wifi capability:

1. Connect the Pit/Host computer to a WiFi router via an ethernet cable.

2. Connect the NVIDIA Jetson NX to the same router via Wifi.

To make this section easy to follow, the Routers WiFi network SSID will be called and referred to ```F1TENTH_WIFI```. In your scenario, it’ll be the SSID of your router’s access point.

## 1. Vehicle Hardware Setup

If you have a NVIDIA Jetson NX, it comes with a network card onboard. Make sure the antennas are connected. The battery should be plugged into the vehicle and the Powerboard should be on.

If you have a NVIDIA Jetson Nano or a Xavier, you’ll need to install an additional M.2 network card from Intel to enable wireless networking.

## 2. Connecting the NVIDIA Jetson NX to WiFi

Power up the F1TENTH vehicle and connect the car to a monitor (via HDMI) and both a mouse and keyboard (via USB). You see the Jetson NX is showing its main Desktop which is an UBUNTU 18.04 version. You can now connect the NVIDIA Jetson NX to the F1TENTH_WIFI by clicking on wireless icon on top-right corner of Ubuntu Desktop and selecting F1TENTH_WIFI. It might take a while for the NVIDIA Jetson NX to discover the wireless network.

![alt text](image-2.png)

After you’re connected to the wireless network, open a terminal and type:

```ifconfig```

You should see something similar to this:

```
eth0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether 00:04:4b:cb:d9:52  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 40

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1  (Local Loopback)
        RX packets 1047  bytes 82631 (82.6 KB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1047  bytes 82631 (82.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

rndis0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether ea:a2:37:fd:d0:e1  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

usb0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether ea:a2:37:fd:d0:e3  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

wlan0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 195.0.0.5  netmask 255.255.255.0  broadcast 195.0.0.255
        inet6 fe80::4df8:b83b:9390:319d  prefixlen 64  scopeid 0x20<link>
        ether 0c:dd:24:99:e6:52  txqueuelen 1000  (Ethernet)
        RX packets 12511  bytes 4918686 (4.9 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1262  bytes 196668 (196.6 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
NoMachine Ctrl+alt+d`

```
You should be able to find your car’s assigned IP address under ```wlan0```, then after inet. In this example, the IP address is ```195.0.0.5```.

## 3. Connecting the Pit/Host Computer to WiFi

Now, on the Pit/Host laptop, connect to the same wireless network, ```F1TENTH_WIFI``` and find its IP Address. Based on what you have a main system (Mac, Linux, Windows) this process differs. If your laptop running Linux or macOS, you could use the same ```ifconfig``` command in the terminal. On macOS, it may be under ```en0``` or ```en1```. .. In this example, the IP address of the Pit is ```192.168.1.151```.

If you’re running Linux on the Pit laptop in a virtual machine (VM), connect the Pit computer to the router. Depending on which VM software you have and the default VM configuration, you may also need to set its network adapter configuration to NAT mode. This ensures your VM will share the wireless connection with your host OS instead of controlling the adapter itself.

## 4. Connecting to the Pit/Host to the NVIDIA Jetson NX

Now that the car and the laptop are on the same network, you should check that you can ping the laptop from the car and you can ping the car from the laptop.

On the NVIDIA Jetson NX, open a terminal and type: ```ping 192.168.1.151``` (This is the IP address of the Pit computer.).
On the Pit computer, open a terminal and type ```ping 195.0.0.5``` (This is the IP address of the NVIDIA Jetson NX).
Remember to replace the IP addresses in the two lines above with your specific addresses.

You can now SSH into your car from your laptop. Use ``ssh`` in the terminal if you’re on [macOS or Linux](https://support.rackspace.com/how-to/connecting-to-a-server-using-ssh-on-linux-or-mac-os/), use [PuTTY](https://www.123-reg.co.uk/support/servers/how-do-i-connect-using-ssh-putty/) if you’re on Windows.

**An example of this ssh command is as follows - ```ssh -p 22 darc-f1-01@10.152.69.216```**

We recommend using [tmux](https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/)  while you’re ssh-ed into the car. Therefore you close the terminal and your code on the car is still running, since the SSH session is only paused. You need to install tmux on the respective system you are using.

<span style="color:red;">

# 5. Using a Remote Desktop

Although we now have SSH access to the car, it is still inconvenient to run GUI application on the car remotely. In this section, we’ll go over how to set up a remote desktop so you can easily use GUI applications like rviz. In our example, we’ll use **NoMachine**. If you’re an advance user, and can find another remote desktop solution that works on the car, feel free to use it.

First, download NoMachine for your **pit/host** computer’s specific OS [here](https://www.nomachine.com/download). Then, while your Jetson is still connected to the monitor, install NoMachine following this guide [here](https://knowledgebase.nomachine.com/AR02R01074). Note that the guide uses Jetson Nano, the same applies to Jetson Xavier NX. You only have to following the Install NoMachine section and don’t have to set up an alternative desktop environment.

After NoMachine is installed on both sides, go to your pit/host’s NoMachine, click **Add** to configure your connection and insert the IP address of the Jetson. You’ll only need to change the Host field. Click connect to connect to the Jetson. You’ll then be prompted the Jetson’s username and password to log in. Now you should have remote desktop access to the Jetson.

#### A. Install [NoMachine](https://www.nomachine.com/download) on Host/Pit computer 
#### B. Download and install NoMachine on Jetson with the following commands
```wget https://www.nomachine.com/free/arm/v8/deb -O nomachine.deb```

```sudo dpkg -i nomachine.deb```
#### C. Setup GNOME Flashback instead of XFCE using NoMachine

Run the following code in terminal

```sudo apt install gnome-session```

```sudo systemctl set-default multi-user.target```

```sudo gedit /usr/NX/etc/node.cfg```

Replace the following DefaultDesktopCommand with ```DefaultDesktopCommand "/usr/bin/gnome-session"``` then save and close.

Run the following line in the terminal

```sudo /usr/NX/bin/nxserver --restart```

```sudo reboot```

```
sudo apt update
sudo apt upgrade
sudo apt install bluetooth bluez bluez-tools
sudo systemctl start bluetooth
sudo systemctl enable bluetooth
```
<span style="color:white;">

# Install F1TENTH Driver Stack

**Note** - 
This section assumes that you have already completed Building the Car and System Configuration.

At the end of this section, you will have the VESC tuned and the lidar connection completed.

**Difficulty Level**: Intermediate-Advanced

**Approximate Time Investment**: 1.5 hour

With the physical car is built and the system configuration setup, we can start to install the firmware needed on the car.

## 1. Configuring the VESC

#### Important Safety Tips
Put your car on an elevated stand so that its wheels can turn without it going anywhere. If you don’t have an RC car stand, you can use the box that came with your Jetson.

Make sure you hold on to the car while testing the motor to prevent it from flying off the stand.

Make sure there are no objects (or people) in the vicinity of the wheels while testing.

Use a fully-charged LiPO battery instead of a power supply to ensure the motor has enough current to spin up.

### 1. Installing the VESC Tool
We need to configure the VESC so that it works with our motor and vehicle transmission. Before you start, you’ll need to install the VESC Tool. You’ll have to register for an account to download. Add the free tier tool to cart (you don’t have to fill in any information other than your email.) After checkout, a download link will be sent to your email address. There should be versions of the software for Linux, Windows and macOS.

### 2. Powering the VESC
First we need to power the VESC. Plug the battery in, and make sure the polarity is correct. Note that you don’t need to turn on the Powerboard for configuring the VESC.

![alt text](<Pictures/F1tenth Build/vesc01.jpeg>)

Next, unplug the USB cable of the VESC from the Jetson NX and plug the USB into your laptop that’s running the VESC Tool. You may want to use a longer cable.

![alt text](<Pictures/F1tenth Build/vesc02.jpeg>)

### 3. Connecting the VESC to Your Laptop
Launch the VESC Tool. On the Welcome page, press the AutoConnect button on bottom left of the page. After the VESC is connected, you should see an updated status on the bottom right of the screen.

![alt text](image-6.png)
Use AutoConnect 

### 4. Updating the Firmware on the VESC
The first thing you’ll need to do is to update the firmware onboard the VESC. Depending on the version of the VESC tool you’re using, you’ll need to go through different steps to enable servo out from the ppm port on the VESC.

With VESC Tool versions released after Mar. 31 2021, you can use the latest default firmware. And to enable servo out, go to **App Settings > General > Enable Servo Output** in the VESC Tool to enable servo out.

![alt text](<Pictures/F1tenth Build/servo.webp>)

### 5. Uploading the Motor Configuration XML
After firmware update, Select Load Motor Configuration XML from the drop down menu and select the provided XML file from here . After the XML is uploaded, click on the Write Motor Configuration button (the button with a down arrow and the letter M) on the right side of the screen to apply the motor configuration. Note that in the future, you’ll have to press this button whenever you make a change in motor configuration.

![alt text](<Pictures/F1tenth Build/xml.webp>)

### 6. Detecting and Calculating Motor Parameters
To detect and calculate the FOC motor parameters, navigate to the FOC tab under Motor Settings on the left. At the bottom of the screen, follow the direction of the arrows and clck on the four buttons one by one, and follow the on screen prompt. Note that during the measuring process, the motor will make noise and spin, make sure the wheels of your vehicle are clear.

![alt text](<Pictures/F1tenth Build/detect_motor.webp>)

After the motor parameters are measured, the fields at the bottom of the screen should turn green. Click on the Apply button, and click the Write Motor Configuration button.

![alt text](<Pictures/F1tenth Build/apply_motor.png>)
### 7. Changing the Openloop Hysteresis and Openloop Time

Navigate to the **Sensorless** tab on top of the screen. Change the **Openloop Hysteresis** and **Openloop Time** to 0.01, and click the **Write Motor Configuration** button.

![alt text](<Pictures/F1tenth Build/open_loop.webp>)

### 8. Tuning the PID controller
Now you can start tuning the speed PID controller. To see the RPM response from the motor, navigate to the **Realtime Data** tab under **Data Analysis** on the left. Click **Stream Realtime Data** button on the right (the button with letters RT), and navigate to the **RPM** tab on the top of the screen. You should see RPM data streaming now.

![alt text](<Pictures/F1tenth Build/realtime.webp>)

To create a step response for the motor, you can set a target RPM at the bottom of the screen (values between 2000 - 10000 RPM). Click the play button next to the text box to start the motor. Note that the motor will spin, so make sure the wheels of your vehicle are clear from objects. Click the Anchor or STOP button to stop the motor.

![alt text](<Pictures/F1tenth Build/response.webp>)

You want to look for a clean step response that has a quick rise time and zero to very little steady state error. Adjust the gains accordingly by navigating to the PID Controllers tab under Motor Settings on the left, and change the Speed Controller gains. General rules of tuning PID gains apply. If you’re seeing a lot of oscillations, try changing the Speed PID Kd Filter.

![alt text](<Pictures/F1tenth Build/pid_gains.webp>)

These are my settings.

![alt text](<Screenshot from 2024-10-07 17-57-01.png>)

### 9. Changing the hardware speed limit
By default, the motor configuration sets a safe top motor RPM. If you wish to change the hard limit set by the VESC firmware, you can go to Motor Settings > General, and change the max ERPM for forward and backwards rotations. You’ll also have to change the configuration file mentioned in the Odometry Tuning section in the software stack setup to change the software limit for your motor ERPM.

![alt text](<Pictures/F1tenth Build/erpm.webp>)

**Danger**
```
Please see the Odometry Tuning section in the software stack setup to see how vehicle velocity is converted to ERPM for the motor to calculate a safe maximum erpm for your motor.
```

## 2. Hokuyo 10LX Ethernet

**Note**

If you have a 30LX or a LIDAR that connects via USB, you can skip this section.


**Approximate Time Investment:** 30 minutes

Connect to the Jetson NX either via SSH or a wired connection (monitor, keyboard, mouse).

In order to utilize the 10LX you must first configure the eth0 network. From the factory the 10LX is assigned the following ip: ```192.168.0.10```. Note that the lidar is on subnet 0.

Open Network Configuration in the Linux GUI on the Jetson NX. In the ipv4 tab, add a route such that the eth0 port is assigned

IP address ```192.168.0.15```

Subnet mask is ```255.255.255.0```

Gateway is ```192.168.0.10```

Call the connection Hokuyo. Save the connection and close the network configuration GUI.

When you plug in the 10LX make sure that the Hokuyo connection is selected. If everything is configured properly you should now be able to ping ```192.168.0.10```.

If thisn doesn't work use the following commands

Open the terminal
```
sudo ip addr add 192.168.0.1/24 dev eth0
```
Then go to setting and edit the eth0 connection. By going to the ipv4 tab and entering in the gateway ```192.168.0.10```. Also double check the IP address and the Subnet mask. Then go to the identiy tab and enter the name Hokuyo.

Now try to ping ```192.168.0.10```.

## 3. F1TENTH Driver Stack Setup

**NOTE: This is how to setup the driver stack WITHOUT DOCKER**

**Approximate Time Investment:** 1.5 hour

### Overview

This setup is being ran on JetPack 6.0 since the Jetson can run on Ubuntu 22.04, and we can install ROS 2 natively and conveniently. We use ROS 2 Humble for communication and run the car. You can find a tutorial on ROS 2 [here](https://docs.ros.org/en/humble/Tutorials.html).


In the following section, we’ll go over how to set up the drivers for sensors and the motor control:

#### A. Setting up udev rules for our sensors.

#### C. Installing ROS 2 and its utilities.

#### D. Setting up the driver stack.

#### E. Launch teleoperation and the LiDAR.

Everything in this section is done on the **Jetson Orin Nano Dev Kit** so you will need to connect to it via SSH from the Pit laptop or plug in the monitor, keyboard, and mouse.

## A. udev Rules Setup

*Goal is to name the VESC and the Hokuyo Lidar (Ethernet connection)

#### Naming the Lidar Sensor

```sudo gedit /etc/udev/rules.d/99-ethernet-hokuyo.rules```

```SUBSYSTEM=="net", ACTION=="add", ATTR{address}=="48:b0:2d:eb:e4:dd", NAME="hokuyo"```

#### Naming the VESC

```sudo gedit /etc/udev/rules.d/99-vesc.rules```

```KERNEL=="ttyACM[0-9]*", ACTION=="add", ATTRS{idVendor}=="0483", ATTRS{idProduct}=="5740", MODE="0666", GROUP="dialout", SYMLINK+="sensors/vesc"```

<span style="color:red;">

#### Naming the PS4 Controller

```sudo gedit /etc/udev/rules.d/99-ps4-controller.rules```

```KERNEL=="js*", SUBSYSTEM=="input", ATTRS{name}=="Wireless Controller", MODE="0666", SYMLINK+="input/ps4"```

<span style="color:white;">

Finally, trigger (activate) the rules by running

```
sudo udevadm control --reload-rules
sudo udevadm trigger
```
Reboot your system, and you should find VESC by running ```ls /dev/sensors```.

find VESC by running ```ls /dev/sensors```.

<span style="color:red;">

## B. Setup Bluetooth and Connect Controller
#### - Steps to Setup Bluetooth on Jetson Orin Nano:
Update System Packages: Make sure the system is up to date.

```
sudo apt update
sudo apt upgrade
```

#### - Install Bluetooth Packages: Install the necessary Bluetooth packages if they’re not already installed.

```
sudo apt install bluez bluez-tools
sudo apt install pulseaudio pulseaudio-module-bluetooth
```

#### - Enable Bluetooth Service: Start and enable the Bluetooth service.

```
sudo systemctl start bluetooth
sudo systemctl enable bluetooth
```

#### -  Verify Bluetooth Adapter: Check if the Bluetooth adapter is recognized by the system.

```
hciconfig
```

If your adapter is detected, you should see output like hci0: Type: BR/EDR .... If no device is found, it might be due to a missing driver or unsupported hardware.

<span style="color:white;">

## C. Installing ROS 2 and its Utilities

Below are instructions on how to install ROS 2 humble and the necessary utilites.

### Set locale
Make sure you have a locale which supports UTF-8. If you are in a minimal environment (such as a docker container), the locale may be something minimal like POSIX. We test with the following settings. However, it should be fine if you’re using a different UTF-8 supported locale.

```
locale  # check for UTF-8

sudo apt update && sudo apt install locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8
export LANG=en_US.UTF-8

locale  # verify settings
```

### Setup Sources
You will need to add the ROS 2 apt repository to your system.

First ensure that the Ubuntu Universe repository is enabled.

```
sudo apt install software-properties-common
sudo add-apt-repository universe
```

Now add the ROS 2 GPG key with apt.

```
sudo apt update && sudo apt install curl -y
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg
```

Then add the repository to your sources list.

```
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
```

### Install ROS 2 packages
Update your apt repository caches after setting up the repositories.

```
sudo apt update
```

ROS 2 packages are built on frequently updated Ubuntu systems. It is always recommended that you ensure your system is up to date before installing new packages.

```
sudo apt upgrade
```
<span style="color:yellow;">

### Warning

Due to early updates in Ubuntu 22.04 it is important that systemd and udev-related packages are updated before installing ROS 2. The installation of ROS 2’s dependencies on a freshly installed system without upgrading can trigger the removal of critical system packages.

Please refer to ros2/ros2#1272 and Launchpad #1974196 for more information.

<span style="color:white;">


Desktop Install (Recommended): ROS, RViz, demos, tutorials.

```
sudo apt install ros-humble-desktop
```

### Try an Example to see if it works

In one terminal, source the setup file and then run a C++ talker:
```
source /opt/ros/humble/setup.bash
ros2 run demo_nodes_cpp talker
```

In another terminal source the setup file and then run a Python listener:

```
source /opt/ros/humble/setup.bash
ros2 run demo_nodes_py listener
```

You should see the `talker` saying that it’s `Publishing` messages and the `listener` saying `I heard` those messages. This verifies both the C++ and Python APIs are working properly. Hooray!

### Now install ROS Utilities

### Install Colcon
```
sudo apt install python3-colcon-common-extensions
```

### Install dependencies
```
sudo apt install python3-bloom python3-rosdep fakeroot debhelper dh-python
```

### Initialize rosdep

Initialize the rosdep database by calling:

```
sudo rosdep init
rosdep update
```
Note that the `rosdep init` command may fail if it has already been initialized in the past; this can safely be ignored.

## D. Setting up the driver stack
First, we’ll create a ROS 2 workspace for our driver stack with the following commands. We’ll be using `f1tenth_ws` as the name of our workspace going forward in this section.

```
cd $HOME
mkdir -p f1tenth_ws/src
```
Then, make this into a ROS 2 workspace by running:

```
cd f1tenth_ws
colcon build
```

Next, we’ll clone the repo into the src directory of our workspace:

```
cd src
git clone https://github.com/f1tenth/f1tenth_system.git
```
Then use the following commands to use the humble-devel branch from the F1tenth repo

```
cd f1tenth_system
git checkout humble-devel
```
Then we’ll update the git submodules and pull in all the necessary packages

```
cd f1tenth_system
git submodule update --init --force --remote
```

After git finishes cloning, we can now install all dependencies for our packages with rosdep:

```
cd $HOME/f1tenth_ws
source /opt/ros/humble/setup.bash
rosdep update
rosdep install --from-paths src -i -y
```

Lastly, after dependencies are installed, we can build our workspace again with the driver stack pacakges:
```
colcon build
```
You can find more details on how the drivers are set up in the README of the f1tenth_system repo.
Install colcon If you haven't installed colcon yet, follow these steps:
### Error

If the following error occurs
```
CMake Error at /opt/ros/humble/share/io_context/cmake/io_context-extras.cmake:17 (find_package):
  By not providing "Findasio_cmake_module.cmake" in CMAKE_MODULE_PATH this
  project has asked CMake to find a package configuration file provided by
  "asio_cmake_module", but CMake did not find one.

  Could not find a package configuration file provided by "asio_cmake_module"
  with any of the following names:

    asio_cmake_moduleConfig.cmake
    asio_cmake_module-config.cmake

  Add the installation prefix of "asio_cmake_module" to CMAKE_PREFIX_PATH or
  set "asio_cmake_module_DIR" to a directory containing one of the above
  files.  If "asio_cmake_module" provides a separate development package or
  SDK, be sure it has been installed.
Call Stack (most recent call first):
  /opt/ros/humble/share/io_context/cmake/io_contextConfig.cmake:41 (include)
  /opt/ros/humble/share/serial_driver/cmake/ament_cmake_export_dependencies-extras.cmake:21 (find_package)
  /opt/ros/humble/share/serial_driver/cmake/serial_driverConfig.cmake:41 (include)
  /opt/ros/humble/share/ament_cmake_auto/cmake/ament_auto_find_build_dependencies.cmake:67 (find_package)
  CMakeLists.txt:14 (ament_auto_find_build_dependencies)
```

Use the following code
```
sudo apt update 
sudo apt install ros-humble-asio-cmake-module
```

**There will be several warnings please use the following commands to midigate these warnings**

Code format: `find . -type f -exec sed -i 's/old/new/g' {} \;`

```
find . -type f -exec sed -i 's/script-dir/script_dir/g' {} \;
find . -type f -exec sed -i 's/install-script/install_script/g' {} \;
```
## E. Launch teleoperation and the LiDAR

This section assumes that the lidar has already been plugged in (either to the USB hub or to the ethernet port). If you are using the Hokuyo 10LX or a lidar that is connected via the ethernet port of the Orbitty, make sure that you have completed the Hokuyo 10LX Ethernet Connection section before preceding.

Before the bringup launch, you’ll have to set the correct parameters according to which LiDAR you’re using in the params file `sensors.yaml`. All parameter files are located in the following location:

```
$HOME/f1tenth_ws/src/f1tenth_system/f1tenth_stack/config/
```
If you’re using an ethernet based LiDAR, set the ip_address field to the corresponding ip address of your LiDAR.

If you’re using a USB based LiDAR, comment out the ip_address field, and uncomment the line with the serial_port field. And set the value to the correct udev name from udev rules set up.

In your running container, run the following commands to source the ROS 2 underlay and our workspace’s overlay:

```
source /opt/ros/humble/setup.bash
cd $HOME/f1tenth_ws
source install/setup.bash
```

Then, you can launch the bring up with:

```
ros2 launch f1tenth_stack bringup_launch.py
```

Running the bringup launch will start the VESC drivers, the LiDAR drivers, the joystick drivers, and all necessary packages for running the car. To see the LaserScan messages, in a new terminal window, run

```
source /opt/ros/humble/setup.bash
cd $HOME/f1tenth_ws
source install/setup.bash
rviz2
```
Change the **Fixed Frame** parameter from **map** to **laser**
The rviz window should show up. Then you can add a LaserScan visualization in rviz on the /scan topic.



If RViz2 is populating a blank screen is could be because RViz2 is misconfigured. Try the following steps.

1. Close RViz2
2. Delete the saved configuration file (if it exists):
```
rm ~/ .rviz2/default.rviz
```
3. Relaunch RViz2:
```
rviz2
```






For Ubuntu 20.04 (and later versions): Update your package list:

sudo apt update
Install colcon:

sudo apt install python3-colcon-common-extensions

cd src
git clone https://github.com/cpsl-research/f1tenth_system

cd f1tenth_system
git submodule update --init --force --remote

cd $HOME/f1tenth_ws
rosdep update
rosdep install --from-paths src -i -y

Step 1: Install rosdep You can install rosdep by following these steps:

Update package lists:

sudo apt update
Install python3-rosdep: This package includes the rosdep tool.

sudo apt install python3-rosdep
Step 2: Initialize rosdep After installing rosdep, you need to initialize it. This is typically done once on a new system.

Initialize rosdep:

sudo rosdep init
Update rosdep:

rosdep update

## ERROR

First, we’ll create a ROS 2 workspace for our driver stack with the following commands. We’ll be using f1tenth_ws as the name of our workspace going forward in this section.

```
cd $HOME
mkdir -p f1tenth_ws/src
```

Then, make this into a ROS 2 workspace by running:

```
cd f1tenth_ws
sudo apt install python3-colcon-common-extensions
colcon build
```

Next, we’ll clone the repo into the src directory of our workspace:

```
cd src
git clone https://github.com/f1tenth/f1tenth_system.git
```

Then we’ll update the git submodules and pull in all the necessary packages

```
cd f1tenth_system
git submodule update --init --force --remote
```

After git finishes cloning, we can now install all dependencies for our packages with rosdep:

```
cd $HOME/f1tenth_ws
sudo apt update
sudo apt install python3-rosdep
sudo rosdep init
rosdep update
rosdep install --from-paths src -i -y
```

Lastly, after dependencies are installed, we can build our workspace again with the driver stack pacakges:

```
colcon build
```
You can find more details on how the drivers are set up in the README of the f1tenth_system repo.

### Issue with ackermann_to_vesc impliment new fork with 
### USDOT-fhwa-stol -->ackermann_to_vesc 
### MIT odom vesc

There are 2 user warning that happen script-dir and install-scripts

`find . -type f -exec sed -i 's/old/new/g' {} \;`

example: `find . -type f -exec sed -i 's/script-dir/script_dir/g' {} \;`


# Test controller

connect the controller using bluetooth from the settings

```
sudo apt install jstest-gtk
```

Then run `jstest-gtk` to open the tester and by selecting the3 wireless controller

![alt text](image-7.png)

# Manual Test of Teleop Commands
If you confirm that joystick inputs are present but the car isn't responding, you can try publishing manual commands to the /ackermann_cmd topic as mentioned before:

```
ros2 topic pub /ackermann_cmd ackermann_msgs/msg/AckermannDriveStamped "drive: {speed: 1.0, steering_angle: 0.0}"
```
